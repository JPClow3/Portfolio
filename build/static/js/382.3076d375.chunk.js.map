{"version":3,"file":"static/js/382.3076d375.chunk.js","mappings":"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","sources":["components/LaserFlow.js"],"sourcesContent":["import React, {useEffect, useRef} from 'react';\r\n// Tree-shake Three.js - import only what we need\r\nimport {\r\n    WebGLRenderer,\r\n    SRGBColorSpace,\r\n    Scene,\r\n    OrthographicCamera,\r\n    BufferGeometry,\r\n    BufferAttribute,\r\n    Vector3,\r\n    Vector4,\r\n    Vector2,\r\n    RawShaderMaterial,\r\n    NormalBlending,\r\n    Mesh,\r\n    Clock\r\n} from 'three';\r\nimport {throttle} from '../utils/throttle';\r\n\r\nconst VERT = `\r\nprecision highp float;\r\nattribute vec3 position;\r\nvoid main(){\r\n  gl_Position = vec4(position, 1.0);\r\n}\r\n`;\r\n\r\nconst FRAG = `\r\n#ifdef GL_ES\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\nprecision highp float;\r\nprecision mediump int;\r\n\r\nuniform float iTime;\r\nuniform vec3 iResolution;\r\nuniform vec4 iMouse;\r\nuniform float uWispDensity;\r\nuniform float uTiltScale;\r\nuniform float uFlowTime;\r\nuniform float uFogTime;\r\nuniform float uBeamXFrac;\r\nuniform float uBeamYFrac;\r\nuniform float uFlowSpeed;\r\nuniform float uVLenFactor;\r\nuniform float uHLenFactor;\r\nuniform float uFogIntensity;\r\nuniform float uFogScale;\r\nuniform float uWSpeed;\r\nuniform float uWIntensity;\r\nuniform float uFlowStrength;\r\nuniform float uDecay;\r\nuniform float uFalloffStart;\r\nuniform float uFogFallSpeed;\r\nuniform vec3 uColor;\r\nuniform float uFade;\r\n\r\n// Core beam/flare shaping and dynamics\r\n#define PI 3.14159265359\r\n#define TWO_PI 6.28318530718\r\n#define EPS 1e-6\r\n#define EDGE_SOFT (DT_LOCAL*4.0)\r\n#define DT_LOCAL 0.0038\r\n#define TAP_RADIUS 6\r\n#define R_H 150.0\r\n#define R_V 150.0\r\n#define FLARE_HEIGHT 16.0\r\n#define FLARE_AMOUNT 8.0\r\n#define FLARE_EXP 2.0\r\n#define TOP_FADE_START 0.1\r\n#define TOP_FADE_EXP 1.0\r\n#define FLOW_PERIOD 0.5\r\n#define FLOW_SHARPNESS 1.5\r\n\r\n// Wisps (animated micro-streaks) that travel along the beam\r\n#define W_BASE_X 1.5\r\n#define W_LAYER_GAP 0.25\r\n#define W_LANES 10\r\n#define W_SIDE_DECAY 0.5\r\n#define W_HALF 0.01\r\n#define W_AA 0.15\r\n#define W_CELL 20.0\r\n#define W_SEG_MIN 0.01\r\n#define W_SEG_MAX 0.55\r\n#define W_CURVE_AMOUNT 15.0\r\n#define W_CURVE_RANGE (FLARE_HEIGHT - 3.0)\r\n#define W_BOTTOM_EXP 10.0\r\n\r\n// Volumetric fog controls\r\n#define FOG_ON 1\r\n#define FOG_CONTRAST 1.2\r\n#define FOG_SPEED_U 0.1\r\n#define FOG_SPEED_V -0.1\r\n#define FOG_OCTAVES 5\r\n#define FOG_BOTTOM_BIAS 0.8\r\n#define FOG_TILT_TO_MOUSE 0.05\r\n#define FOG_TILT_DEADZONE 0.01\r\n#define FOG_TILT_MAX_X 0.35\r\n#define FOG_TILT_SHAPE 1.5\r\n#define FOG_BEAM_MIN 0.0\r\n#define FOG_BEAM_MAX 0.75\r\n#define FOG_MASK_GAMMA 0.5\r\n#define FOG_EXPAND_SHAPE 12.2\r\n#define FOG_EDGE_MIX 0.5\r\n\r\n// Horizontal vignette for the fog volume\r\n#define HFOG_EDGE_START 0.20\r\n#define HFOG_EDGE_END 0.98\r\n#define HFOG_EDGE_GAMMA 1.4\r\n#define HFOG_Y_RADIUS 25.0\r\n#define HFOG_Y_SOFT 60.0\r\n\r\n// Beam extents and edge masking\r\n#define EDGE_X0 0.22\r\n#define EDGE_X1 0.995\r\n#define EDGE_X_GAMMA 1.25\r\n#define EDGE_LUMA_T0 0.0\r\n#define EDGE_LUMA_T1 2.0\r\n#define DITHER_STRENGTH 1.0\r\n\r\n    float g(float x){return x<=0.00031308?12.92*x:1.055*pow(x,1.0/2.4)-0.055;}\r\n    float bs(vec2 p,vec2 q,float powr){\r\n        float d=distance(p,q),f=powr*uFalloffStart,r=(f*f)/(d*d+EPS);\r\n        return powr*min(1.0,r);\r\n    }\r\n    float bsa(vec2 p,vec2 q,float powr,vec2 s){\r\n        vec2 d=p-q; float dd=(d.x*d.x)/(s.x*s.x)+(d.y*d.y)/(s.y*s.y),f=powr*uFalloffStart,r=(f*f)/(dd+EPS);\r\n        return powr*min(1.0,r);\r\n    }\r\n    float tri01(float x){float f=fract(x);return 1.0-abs(f*2.0-1.0);}\r\n    float tauWf(float t,float tmin,float tmax){float a=smoothstep(tmin,tmin+EDGE_SOFT,t),b=1.0-smoothstep(tmax-EDGE_SOFT,tmax,t);return max(0.0,a*b);} \r\n    float h21(vec2 p){p=fract(p*vec2(123.34,456.21));p+=dot(p,p+34.123);return fract(p.x*p.y);}\r\n    float vnoise(vec2 p){\r\n        vec2 i=floor(p),f=fract(p);\r\n        float a=h21(i),b=h21(i+vec2(1,0)),c=h21(i+vec2(0,1)),d=h21(i+vec2(1,1));\r\n        vec2 u=f*f*(3.0-2.0*f);\r\n        return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);\r\n    }\r\n    float fbm2(vec2 p){\r\n        float v=0.0,amp=0.6; mat2 m=mat2(0.86,0.5,-0.5,0.86);\r\n        for(int i=0;i<FOG_OCTAVES;++i){v+=amp*vnoise(p); p=m*p*2.03+17.1; amp*=0.52;}\r\n        return v;\r\n    }\r\n    float rGate(float x,float l){float a=smoothstep(0.0,W_AA,x),b=1.0-smoothstep(l,l+W_AA,x);return max(0.0,a*b);}\r\n    float flareY(float y){float t=clamp(1.0-(clamp(y,0.0,FLARE_HEIGHT)/max(FLARE_HEIGHT,EPS)),0.0,1.0);return pow(t,FLARE_EXP);}\r\n\r\n    float vWisps(vec2 uv,float topF){\r\n    float y=uv.y,yf=(y+uFlowTime*uWSpeed)/W_CELL;\r\n    float dRaw=clamp(uWispDensity,0.0,2.0),d=dRaw<=0.0?1.0:dRaw;\r\n    float lanesF=floor(float(W_LANES)*min(d,1.0)+0.5); // WebGL1-safe\r\n    int lanes=int(max(1.0,lanesF));\r\n    float sp=min(d,1.0),ep=max(d-1.0,0.0);\r\n    float fm=flareY(max(y,0.0)),rm=clamp(1.0-(y/max(W_CURVE_RANGE,EPS)),0.0,1.0),cm=fm*rm;\r\n    const float G=0.05; float xS=1.0+(FLARE_AMOUNT*W_CURVE_AMOUNT*G)*cm;\r\n    float sPix=clamp(y/R_V,0.0,1.0),bGain=pow(1.0-sPix,W_BOTTOM_EXP),sum=0.0;\r\n    for(int s=0;s<2;++s){\r\n        float sgn=s==0?-1.0:1.0;\r\n        for(int i=0;i<W_LANES;++i){\r\n            if(i>=lanes) break;\r\n            float off=W_BASE_X+float(i)*W_LAYER_GAP,xc=sgn*(off*xS);\r\n            float dx=abs(uv.x-xc),lat=1.0-smoothstep(W_HALF,W_HALF+W_AA,dx),amp=exp(-off*W_SIDE_DECAY);\r\n            float seed=h21(vec2(off,sgn*17.0)),yf2=yf+seed*7.0,ci=floor(yf2),fy=fract(yf2);\r\n            float seg=mix(W_SEG_MIN,W_SEG_MAX,h21(vec2(ci,off*2.3)));\r\n            float spR=h21(vec2(ci,off+sgn*31.0)),seg1=rGate(fy,seg)*step(spR,sp);\r\n            if(ep>0.0){float spR2=h21(vec2(ci*3.1+7.0,off*5.3+sgn*13.0)); float f2=fract(fy+0.5); seg1+=rGate(f2,seg*0.9)*step(spR2,ep);}\r\n            sum+=amp*lat*seg1;\r\n        }\r\n    }\r\n    float span=smoothstep(-3.0,0.0,y)*(1.0-smoothstep(R_V-6.0,R_V,y));\r\n    return uWIntensity*sum*topF*bGain*span;\r\n}\r\n\r\nvoid mainImage(out vec4 fc,in vec2 frag){\r\n    vec2 C=iResolution.xy*.5; float invW=1.0/max(C.x,1.0);\r\n    float sc=512.0/iResolution.x*.4;\r\n    vec2 uv=(frag-C)*sc,off=vec2(uBeamXFrac*iResolution.x*sc,uBeamYFrac*iResolution.y*sc);\r\n    vec2 uvc = uv - off;\r\n    float a=0.0,b=0.0;\r\n    float basePhase=1.5*PI+uDecay*.5; float tauMin=basePhase-uDecay; float tauMax=basePhase;\r\n    float cx=clamp(uvc.x/(R_H*uHLenFactor),-1.0,1.0),tH=clamp(TWO_PI-acos(cx),tauMin,tauMax);\r\n    for(int k=-TAP_RADIUS;k<=TAP_RADIUS;++k){\r\n        float tu=tH+float(k)*DT_LOCAL,wt=tauWf(tu,tauMin,tauMax); if(wt<=0.0) continue;\r\n        float spd=max(abs(sin(tu)),0.02),u=clamp((basePhase-tu)/max(uDecay,EPS),0.0,1.0),env=pow(1.0-abs(u*2.0-1.0),0.8);\r\n        vec2 p=vec2((R_H*uHLenFactor)*cos(tu),0.0);\r\n        a+=wt*bs(uvc,p,env*spd);\r\n    }\r\n    float yPix=uvc.y,cy=clamp(-yPix/(R_V*uVLenFactor),-1.0,1.0),tV=clamp(TWO_PI-acos(cy),tauMin,tauMax);\r\n    for(int k=-TAP_RADIUS;k<=TAP_RADIUS;++k){\r\n        float tu=tV+float(k)*DT_LOCAL,wt=tauWf(tu,tauMin,tauMax); if(wt<=0.0) continue;\r\n        float yb=(-R_V)*cos(tu),s=clamp(yb/R_V,0.0,1.0),spd=max(abs(sin(tu)),0.02);\r\n        float env=pow(1.0-s,0.6)*spd;\r\n        float cap=1.0-smoothstep(TOP_FADE_START,1.0,s); cap=pow(cap,TOP_FADE_EXP); env*=cap;\r\n        float ph=s/max(FLOW_PERIOD,EPS)+uFlowTime*uFlowSpeed;\r\n        float fl=pow(tri01(ph),FLOW_SHARPNESS);\r\n        env*=mix(1.0-uFlowStrength,1.0,fl);\r\n        float yp=(-R_V*uVLenFactor)*cos(tu),m=pow(smoothstep(FLARE_HEIGHT,0.0,yp),FLARE_EXP),wx=1.0+FLARE_AMOUNT*m;\r\n        vec2 sig=vec2(wx,1.0),p=vec2(0.0,yp);\r\n        float mask=step(0.0,yp);\r\n        b+=wt*bsa(uvc,p,mask*env,sig);\r\n    }\r\n    float sPix=clamp(yPix/R_V,0.0,1.0),topA=pow(1.0-smoothstep(TOP_FADE_START,1.0,sPix),TOP_FADE_EXP);\r\n    float L=a+b*topA;\r\n    float w=vWisps(vec2(uvc.x,yPix),topA);\r\n    float fog=0.0;\r\n#if FOG_ON\r\n    vec2 fuv=uvc*uFogScale;\r\n    float mAct=step(1.0,length(iMouse.xy)),nx=((iMouse.x-C.x)*invW)*mAct;\r\n    float ax = abs(nx);\r\n    float stMag = mix(ax, pow(ax, FOG_TILT_SHAPE), 0.35);\r\n    float st = sign(nx) * stMag * uTiltScale;\r\n    st = clamp(st, -FOG_TILT_MAX_X, FOG_TILT_MAX_X);\r\n    vec2 dir=normalize(vec2(st,1.0));\r\n    fuv+=uFogTime*uFogFallSpeed*dir;\r\n    vec2 prp=vec2(-dir.y,dir.x);\r\n    fuv+=prp*(0.08*sin(dot(uvc,prp)*0.08+uFogTime*0.9));\r\n    float n=fbm2(fuv+vec2(fbm2(fuv+vec2(7.3,2.1)),fbm2(fuv+vec2(-3.7,5.9)))*0.6);\r\n    n=pow(clamp(n,0.0,1.0),FOG_CONTRAST);\r\n    float pixW = 1.0 / max(iResolution.y, 1.0);\r\n#ifdef GL_OES_standard_derivatives\r\n    float wL = max(fwidth(L), pixW);\r\n#else\r\n    float wL = pixW;\r\n#endif\r\n    float m0=pow(smoothstep(FOG_BEAM_MIN - wL, FOG_BEAM_MAX + wL, L),FOG_MASK_GAMMA);\r\n    float bm=1.0-pow(1.0-m0,FOG_EXPAND_SHAPE); bm=mix(bm*m0,bm,FOG_EDGE_MIX);\r\n    float yP=1.0-smoothstep(HFOG_Y_RADIUS,HFOG_Y_RADIUS+HFOG_Y_SOFT,abs(yPix));\r\n    float nxF=abs((frag.x-C.x)*invW),hE=1.0-smoothstep(HFOG_EDGE_START,HFOG_EDGE_END,nxF); hE=pow(clamp(hE,0.0,1.0),HFOG_EDGE_GAMMA);\r\n    float hW=mix(1.0,hE,clamp(yP,0.0,1.0));\r\n    float bBias=mix(1.0,1.0-sPix,FOG_BOTTOM_BIAS);\r\n    float browserFogIntensity = uFogIntensity;\r\n    browserFogIntensity *= 1.8;\r\n    float radialFade = 1.0 - smoothstep(0.0, 0.7, length(uvc) / 120.0);\r\n    float safariFog = n * browserFogIntensity * bBias * bm * hW * radialFade;\r\n    fog = safariFog;\r\n#endif\r\n    float LF=L+fog;\r\n    float dith=(h21(frag)-0.5)*(DITHER_STRENGTH/255.0);\r\n    float tone=g(LF+w);\r\n    vec3 col=tone*uColor+dith;\r\n    float alpha=clamp(g(L+w*0.6)+dith*0.6,0.0,1.0);\r\n    float nxE=abs((frag.x-C.x)*invW),xF=pow(clamp(1.0-smoothstep(EDGE_X0,EDGE_X1,nxE),0.0,1.0),EDGE_X_GAMMA);\r\n    float scene=LF+max(0.0,w)*0.5,hi=smoothstep(EDGE_LUMA_T0,EDGE_LUMA_T1,scene);\r\n    float eM=mix(xF,1.0,hi);\r\n    col*=eM; alpha*=eM;\r\n    col*=uFade; alpha*=uFade;\r\n    fc=vec4(col,alpha);\r\n}\r\n\r\nvoid main(){\r\n  vec4 fc;\r\n  mainImage(fc, gl_FragCoord.xy);\r\n  gl_FragColor = fc;\r\n}\r\n`;\r\n\r\nexport const LaserFlow = ({\r\n                              className,\r\n                              style,\r\n                              wispDensity = 1,\r\n                              dpr,\r\n                              mouseSmoothTime = 0.0,\r\n                              mouseTiltStrength = 0.01,\r\n                              horizontalBeamOffset = 0.1,\r\n                              verticalBeamOffset = 0.0,\r\n                              flowSpeed = 0.35,\r\n                              verticalSizing = 2.0,\r\n                              horizontalSizing = 0.5,\r\n                              fogIntensity = 0.45,\r\n                              fogScale = 0.3,\r\n                              wispSpeed = 15.0,\r\n                              wispIntensity = 5.0,\r\n                              flowStrength = 0.25,\r\n                              decay = 1.1,\r\n                              falloffStart = 1.2,\r\n                              fogFallSpeed = 0.6,\r\n                              color = '#FF79C6'\r\n                          }) => {\r\n    const mountRef = useRef(null);\r\n    const rendererRef = useRef(null);\r\n    const uniformsRef = useRef(null);\r\n    const hasFadedRef = useRef(false);\r\n    const rectRef = useRef(null);\r\n    const baseDprRef = useRef(1);\r\n    const currentDprRef = useRef(1);\r\n    const fpsSamplesRef = useRef([]);\r\n    const lastFpsCheckRef = useRef(performance.now());\r\n    const emaDtRef = useRef(16.7);\r\n    const pausedRef = useRef(false);\r\n    const inViewRef = useRef(true);\r\n\r\n    const hexToRGB = hex => {\r\n        let c = hex.trim();\r\n        if (c[0] === '#') c = c.slice(1);\r\n        if (c.length === 3)\r\n            c = c\r\n                .split('')\r\n                .map(x => x + x)\r\n                .join('');\r\n        const n = parseInt(c, 16) || 0xffffff;\r\n        return {r: ((n >> 16) & 255) / 255, g: ((n >> 8) & 255) / 255, b: (n & 255) / 255};\r\n    };\r\n\r\n    useEffect(() => {\r\n        const mount = mountRef.current;\r\n        const renderer = new WebGLRenderer({\r\n            antialias: false,\r\n            alpha: false,\r\n            depth: false,\r\n            stencil: false,\r\n            powerPreference: 'high-performance',\r\n            premultipliedAlpha: false,\r\n            preserveDrawingBuffer: false,\r\n            failIfMajorPerformanceCaveat: false,\r\n            logarithmicDepthBuffer: false\r\n        });\r\n        rendererRef.current = renderer;\r\n\r\n        baseDprRef.current = Math.min(dpr ?? (window.devicePixelRatio || 1), 2);\r\n        currentDprRef.current = baseDprRef.current;\r\n\r\n        renderer.setPixelRatio(currentDprRef.current);\r\n        renderer.shadowMap.enabled = false;\r\n        renderer.outputColorSpace = SRGBColorSpace;\r\n        renderer.setClearColor(0x000000, 1);\r\n        const canvas = renderer.domElement;\r\n        canvas.style.width = '100%';\r\n        canvas.style.height = '100%';\r\n        canvas.style.display = 'block';\r\n        mount.appendChild(canvas);\r\n\r\n        const scene = new Scene();\r\n        const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\r\n\r\n        const geometry = new BufferGeometry();\r\n        geometry.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 3));\r\n\r\n        const uniforms = {\r\n            iTime: {value: 0},\r\n            iResolution: {value: new Vector3(1, 1, 1)},\r\n            iMouse: {value: new Vector4(0, 0, 0, 0)},\r\n            uWispDensity: {value: wispDensity},\r\n            uTiltScale: {value: mouseTiltStrength},\r\n            uFlowTime: {value: 0},\r\n            uFogTime: {value: 0},\r\n            uBeamXFrac: {value: horizontalBeamOffset},\r\n            uBeamYFrac: {value: verticalBeamOffset},\r\n            uFlowSpeed: {value: flowSpeed},\r\n            uVLenFactor: {value: verticalSizing},\r\n            uHLenFactor: {value: horizontalSizing},\r\n            uFogIntensity: {value: fogIntensity},\r\n            uFogScale: {value: fogScale},\r\n            uWSpeed: {value: wispSpeed},\r\n            uWIntensity: {value: wispIntensity},\r\n            uFlowStrength: {value: flowStrength},\r\n            uDecay: {value: decay},\r\n            uFalloffStart: {value: falloffStart},\r\n            uFogFallSpeed: {value: fogFallSpeed},\r\n            uColor: {value: new Vector3(1, 1, 1)},\r\n            uFade: {value: hasFadedRef.current ? 1 : 0}\r\n        };\r\n        uniformsRef.current = uniforms;\r\n\r\n        const material = new RawShaderMaterial({\r\n            vertexShader: VERT,\r\n            fragmentShader: FRAG,\r\n            uniforms,\r\n            transparent: false,\r\n            depthTest: false,\r\n            depthWrite: false,\r\n            blending: NormalBlending\r\n        });\r\n\r\n        const mesh = new Mesh(geometry, material);\r\n        mesh.frustumCulled = false;\r\n        scene.add(mesh);\r\n\r\n        const clock = new Clock();\r\n        let prevTime = 0;\r\n        let fade = hasFadedRef.current ? 1 : 0;\r\n\r\n        const mouseTarget = new Vector2(0, 0);\r\n        const mouseSmooth = new Vector2(0, 0);\r\n\r\n        const setSizeNow = () => {\r\n            // Batch DOM reads first\r\n            const w = mount.clientWidth || 1;\r\n            const h = mount.clientHeight || 1;\r\n            const pr = currentDprRef.current;\r\n            \r\n            // Batch DOM writes immediately (already in RAF from scheduleResize)\r\n            renderer.setPixelRatio(pr);\r\n            renderer.setSize(w, h, false);\r\n            uniforms.iResolution.value.set(w * pr, h * pr, pr);\r\n            // Cache rect for mouse calculations (only read when needed)\r\n            rectRef.current = canvas.getBoundingClientRect();\r\n        };\r\n\r\n        let resizeRaf = 0;\r\n        const scheduleResize = () => {\r\n            if (resizeRaf) cancelAnimationFrame(resizeRaf);\r\n            resizeRaf = requestAnimationFrame(setSizeNow);\r\n        };\r\n\r\n        setSizeNow();\r\n        const ro = new ResizeObserver(scheduleResize);\r\n        ro.observe(mount);\r\n\r\n        const io = new IntersectionObserver(\r\n            entries => {\r\n                const isIntersecting = entries[0]?.isIntersecting ?? true;\r\n                const wasVisible = inViewRef.current;\r\n                inViewRef.current = isIntersecting;\r\n                \r\n                // Restart animation if becoming visible\r\n                if (isIntersecting && !wasVisible && !pausedRef.current && !raf) {\r\n                    raf = requestAnimationFrame(animate);\r\n                }\r\n            },\r\n            {root: null, threshold: 0}\r\n        );\r\n        io.observe(mount);\r\n\r\n        const onVis = () => {\r\n            const wasPaused = pausedRef.current;\r\n            pausedRef.current = document.hidden;\r\n            \r\n            // Restart animation if becoming visible\r\n            if (!document.hidden && wasPaused && inViewRef.current && !raf) {\r\n                raf = requestAnimationFrame(animate);\r\n            }\r\n        };\r\n        document.addEventListener('visibilitychange', onVis, {passive: true});\r\n\r\n        const updateMouse = (clientX, clientY) => {\r\n            // Use cached rect if available, otherwise read once per frame\r\n            if (!rectRef.current) {\r\n                rectRef.current = canvas.getBoundingClientRect();\r\n            }\r\n            const rect = rectRef.current;\r\n            const x = clientX - rect.left;\r\n            const y = clientY - rect.top;\r\n            const ratio = currentDprRef.current;\r\n            const hb = rect.height * ratio;\r\n            mouseTarget.set(x * ratio, hb - y * ratio);\r\n        };\r\n        // Throttle mouse move events to ~60fps (16ms)\r\n        const throttledUpdateMouse = throttle(updateMouse, 16);\r\n        const onMove = ev => throttledUpdateMouse(ev.clientX, ev.clientY);\r\n        const onLeave = () => {\r\n            mouseTarget.set(0, 0);\r\n            // Invalidate cached rect on mouse leave\r\n            rectRef.current = null;\r\n        };\r\n        canvas.addEventListener('pointermove', onMove, {passive: true});\r\n        canvas.addEventListener('pointerdown', onMove, {passive: true});\r\n        canvas.addEventListener('pointerenter', onMove, {passive: true});\r\n        canvas.addEventListener('pointerleave', onLeave, {passive: true});\r\n\r\n        const onCtxLost = e => {\r\n            e.preventDefault();\r\n            pausedRef.current = true;\r\n            // Cancel any pending RAF\r\n            if (raf) {\r\n                cancelAnimationFrame(raf);\r\n                raf = 0;\r\n            }\r\n        };\r\n        const onCtxRestored = () => {\r\n            // Reinitialize after context restoration\r\n            pausedRef.current = false;\r\n            \r\n            // Reset clock\r\n            clock.start();\r\n            prevTime = 0;\r\n            \r\n            // Reset fade state\r\n            hasFadedRef.current = false;\r\n            \r\n            // Resize and update uniforms\r\n            scheduleResize();\r\n            \r\n            // Reset uniform values - they'll be updated by the useEffect hook\r\n            // that watches for prop changes, but we reset time-based ones here\r\n            const uniforms = uniformsRef.current;\r\n            if (uniforms) {\r\n                uniforms.iTime.value = 0;\r\n                uniforms.uFlowTime.value = 0;\r\n                uniforms.uFogTime.value = 0;\r\n                uniforms.uFade.value = 0;\r\n            }\r\n            \r\n            // Restart animation if visible\r\n            if (!pausedRef.current && inViewRef.current && !raf) {\r\n                raf = requestAnimationFrame(animate);\r\n            }\r\n        };\r\n        canvas.addEventListener('webglcontextlost', onCtxLost, false);\r\n        canvas.addEventListener('webglcontextrestored', onCtxRestored, false);\r\n\r\n        let raf = 0;\r\n\r\n        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));\r\n        const dprFloor = 0.6;\r\n        const lowerThresh = 50;\r\n        const upperThresh = 58;\r\n\r\n        // Batch DPR adjustments to avoid frequent reflows\r\n        let dprUpdatePending = false;\r\n        let pendingDprValue = null;\r\n        \r\n        const adjustDprIfNeeded = now => {\r\n            const elapsed = now - lastFpsCheckRef.current;\r\n            if (elapsed < 750) return;\r\n\r\n            const samples = fpsSamplesRef.current;\r\n            if (samples.length === 0) {\r\n                lastFpsCheckRef.current = now;\r\n                return;\r\n            }\r\n            const avgFps = samples.reduce((a, b) => a + b, 0) / samples.length;\r\n\r\n            let next = currentDprRef.current;\r\n            const base = baseDprRef.current;\r\n\r\n            if (avgFps < lowerThresh) {\r\n                next = clamp(currentDprRef.current * 0.9, dprFloor, base);\r\n            } else if (avgFps > upperThresh && currentDprRef.current < base) {\r\n                next = clamp(currentDprRef.current * 1.05, dprFloor, base);\r\n            }\r\n\r\n            if (Math.abs(next - currentDprRef.current) > 0.01) {\r\n                pendingDprValue = next;\r\n                if (!dprUpdatePending) {\r\n                    dprUpdatePending = true;\r\n                    // Batch DPR update on next frame to avoid reflow\r\n                    requestAnimationFrame(() => {\r\n                        if (pendingDprValue !== null) {\r\n                            currentDprRef.current = pendingDprValue;\r\n                            setSizeNow();\r\n                            pendingDprValue = null;\r\n                        }\r\n                        dprUpdatePending = false;\r\n                    });\r\n                }\r\n            }\r\n\r\n            fpsSamplesRef.current = [];\r\n            lastFpsCheckRef.current = now;\r\n        };\r\n\r\n        const animate = () => {\r\n            // Only schedule next frame if visible and active\r\n            if (pausedRef.current || !inViewRef.current) {\r\n                raf = 0;\r\n                return;\r\n            }\r\n\r\n            const t = clock.getElapsedTime();\r\n            const dt = Math.max(0, t - prevTime);\r\n            prevTime = t;\r\n\r\n            const dtMs = dt * 1000;\r\n            emaDtRef.current = emaDtRef.current * 0.9 + dtMs * 0.1;\r\n            const instFps = 1000 / Math.max(1, emaDtRef.current);\r\n            fpsSamplesRef.current.push(instFps);\r\n\r\n            uniforms.iTime.value = t;\r\n\r\n            const cdt = Math.min(0.033, Math.max(0.001, dt));\r\n            uniforms.uFlowTime.value += cdt;\r\n            uniforms.uFogTime.value += cdt;\r\n\r\n            if (!hasFadedRef.current) {\r\n                const fadeDur = 1.0;\r\n                fade = Math.min(1, fade + cdt / fadeDur);\r\n                uniforms.uFade.value = fade;\r\n                if (fade >= 1) hasFadedRef.current = true;\r\n            }\r\n\r\n            const tau = Math.max(1e-3, mouseSmoothTime);\r\n            const alpha = 1 - Math.exp(-cdt / tau);\r\n            mouseSmooth.lerp(mouseTarget, alpha);\r\n            uniforms.iMouse.value.set(mouseSmooth.x, mouseSmooth.y, 0, 0);\r\n\r\n            renderer.render(scene, camera);\r\n\r\n            adjustDprIfNeeded(performance.now());\r\n            \r\n            // Schedule next frame only if still visible and active\r\n            if (!pausedRef.current && inViewRef.current) {\r\n                raf = requestAnimationFrame(animate);\r\n            } else {\r\n                raf = 0;\r\n            }\r\n        };\r\n\r\n        // Start animation only if visible\r\n        if (!pausedRef.current && inViewRef.current) {\r\n            raf = requestAnimationFrame(animate);\r\n        }\r\n\r\n        return () => {\r\n            cancelAnimationFrame(raf);\r\n            ro.disconnect();\r\n            io.disconnect();\r\n            document.removeEventListener('visibilitychange', onVis);\r\n            canvas.removeEventListener('pointermove', onMove);\r\n            canvas.removeEventListener('pointerdown', onMove);\r\n            canvas.removeEventListener('pointerenter', onMove);\r\n            canvas.removeEventListener('pointerleave', onLeave);\r\n            canvas.removeEventListener('webglcontextlost', onCtxLost);\r\n            canvas.removeEventListener('webglcontextrestored', onCtxRestored);\r\n            geometry.dispose();\r\n            material.dispose();\r\n            renderer.dispose();\r\n            if (mount.contains(canvas)) mount.removeChild(canvas);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [dpr]);\r\n\r\n    useEffect(() => {\r\n        const uniforms = uniformsRef.current;\r\n        if (!uniforms) return;\r\n\r\n        uniforms.uWispDensity.value = wispDensity;\r\n        uniforms.uTiltScale.value = mouseTiltStrength;\r\n        uniforms.uBeamXFrac.value = horizontalBeamOffset;\r\n        uniforms.uBeamYFrac.value = verticalBeamOffset;\r\n        uniforms.uFlowSpeed.value = flowSpeed;\r\n        uniforms.uVLenFactor.value = verticalSizing;\r\n        uniforms.uHLenFactor.value = horizontalSizing;\r\n        uniforms.uFogIntensity.value = fogIntensity;\r\n        uniforms.uFogScale.value = fogScale;\r\n        uniforms.uWSpeed.value = wispSpeed;\r\n        uniforms.uWIntensity.value = wispIntensity;\r\n        uniforms.uFlowStrength.value = flowStrength;\r\n        uniforms.uDecay.value = decay;\r\n        uniforms.uFalloffStart.value = falloffStart;\r\n        uniforms.uFogFallSpeed.value = fogFallSpeed;\r\n\r\n        const {r, g, b} = hexToRGB(color || '#FFFFFF');\r\n        uniforms.uColor.value.set(r, g, b);\r\n    }, [\r\n        wispDensity,\r\n        mouseTiltStrength,\r\n        horizontalBeamOffset,\r\n        verticalBeamOffset,\r\n        flowSpeed,\r\n        verticalSizing,\r\n        horizontalSizing,\r\n        fogIntensity,\r\n        fogScale,\r\n        wispSpeed,\r\n        wispIntensity,\r\n        flowStrength,\r\n        decay,\r\n        falloffStart,\r\n        fogFallSpeed,\r\n        color\r\n    ]);\r\n\r\n    return <div ref={mountRef} className={`w-full h-full relative ${className || ''}`} style={style}/>;\r\n};\r\n\r\nexport default LaserFlow;\r\n"],"names":["LaserFlow","_ref","className","style","wispDensity","dpr","mouseSmoothTime","mouseTiltStrength","horizontalBeamOffset","verticalBeamOffset","flowSpeed","verticalSizing","horizontalSizing","fogIntensity","fogScale","wispSpeed","wispIntensity","flowStrength","decay","falloffStart","fogFallSpeed","color","mountRef","useRef","rendererRef","uniformsRef","hasFadedRef","rectRef","baseDprRef","currentDprRef","fpsSamplesRef","lastFpsCheckRef","performance","now","emaDtRef","pausedRef","inViewRef","useEffect","mount","current","renderer","WebGLRenderer","antialias","alpha","depth","stencil","powerPreference","premultipliedAlpha","preserveDrawingBuffer","failIfMajorPerformanceCaveat","logarithmicDepthBuffer","Math","min","window","devicePixelRatio","setPixelRatio","shadowMap","enabled","outputColorSpace","SRGBColorSpace","setClearColor","canvas","domElement","width","height","display","appendChild","scene","Scene","camera","OrthographicCamera","geometry","BufferGeometry","setAttribute","BufferAttribute","Float32Array","uniforms","iTime","value","iResolution","Vector3","iMouse","Vector4","uWispDensity","uTiltScale","uFlowTime","uFogTime","uBeamXFrac","uBeamYFrac","uFlowSpeed","uVLenFactor","uHLenFactor","uFogIntensity","uFogScale","uWSpeed","uWIntensity","uFlowStrength","uDecay","uFalloffStart","uFogFallSpeed","uColor","uFade","material","RawShaderMaterial","vertexShader","fragmentShader","transparent","depthTest","depthWrite","blending","NormalBlending","mesh","Mesh","frustumCulled","add","clock","Clock","prevTime","fade","mouseTarget","Vector2","mouseSmooth","setSizeNow","w","clientWidth","h","clientHeight","pr","setSize","set","getBoundingClientRect","resizeRaf","scheduleResize","cancelAnimationFrame","requestAnimationFrame","ro","ResizeObserver","observe","io","IntersectionObserver","entries","_entries$0$isIntersec","_entries$","isIntersecting","wasVisible","raf","animate","root","threshold","onVis","wasPaused","document","hidden","addEventListener","passive","throttledUpdateMouse","throttle","updateMouse","clientX","clientY","rect","x","left","y","top","ratio","hb","onMove","ev","onLeave","onCtxLost","e","preventDefault","onCtxRestored","start","clamp","v","lo","hi","max","dprUpdatePending","pendingDprValue","t","getElapsedTime","dt","dtMs","instFps","push","cdt","fadeDur","tau","exp","lerp","render","samples","length","avgFps","reduce","a","b","next","base","abs","adjustDprIfNeeded","disconnect","removeEventListener","dispose","contains","removeChild","r","g","hex","c","trim","slice","split","map","join","n","parseInt","hexToRGB","_jsx","ref","concat"],"sourceRoot":""}