"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[382],{382:(e,n,t)=>{t.r(n),t.d(n,{LaserFlow:()=>f,default:()=>u});var a=t(43),o=t(408),i=t(435),r=t(916),l=t(579);const f=({className:e,style:n,wispDensity:t=1,dpr:f,mouseSmoothTime:u=0,mouseTiltStrength:s=.01,horizontalBeamOffset:c=.1,verticalBeamOffset:m=0,flowSpeed:d=.35,verticalSizing:p=2,horizontalSizing:_=.5,fogIntensity:v=.45,fogScale:F=.3,wispSpeed:E=15,wispIntensity:A=5,flowStrength:x=.25,decay:h=1.1,falloffStart:S=1.2,fogFallSpeed:T=.6,color:g="#FF79C6"})=>{const w=(0,a.useRef)(null),G=(0,a.useRef)(null),O=(0,a.useRef)(null),L=(0,a.useRef)(!1),R=(0,a.useRef)(null),y=(0,a.useRef)(1),M=(0,a.useRef)(1),D=(0,a.useRef)([]),P=(0,a.useRef)(performance.now()),b=(0,a.useRef)(16.7),W=(0,a.useRef)(!1),I=(0,a.useRef)(!0);return(0,a.useEffect)(()=>{if("undefined"!==typeof window&&window.matchMedia&&window.matchMedia("(prefers-reduced-motion: reduce)").matches)return;const e=w.current,n=new o.JeP({antialias:!1,alpha:!1,depth:!1,stencil:!1,powerPreference:"high-performance",premultipliedAlpha:!1,preserveDrawingBuffer:!1,failIfMajorPerformanceCaveat:!1,logarithmicDepthBuffer:!1});G.current=n,y.current=Math.min(null!==f&&void 0!==f?f:window.devicePixelRatio||1,2),M.current=y.current,n.setPixelRatio(M.current),n.shadowMap.enabled=!1,n.outputColorSpace=i.er$,n.setClearColor(0,1);const a=n.domElement;a.style.width="100%",a.style.height="100%",a.style.display="block",e.appendChild(a);const l=new i.Z58,g=new i.qUd(-1,1,1,-1,0,1),H=new i.LoY;H.setAttribute("position",new i.THS(new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),3));const C={iTime:{value:0},iResolution:{value:new i.Pq0(1,1,1)},iMouse:{value:new i.IUQ(0,0,0,0)},uWispDensity:{value:t},uTiltScale:{value:s},uFlowTime:{value:0},uFogTime:{value:0},uBeamXFrac:{value:c},uBeamYFrac:{value:m},uFlowSpeed:{value:d},uVLenFactor:{value:p},uHLenFactor:{value:_},uFogIntensity:{value:v},uFogScale:{value:F},uWSpeed:{value:E},uWIntensity:{value:A},uFlowStrength:{value:x},uDecay:{value:h},uFalloffStart:{value:S},uFogFallSpeed:{value:T},uColor:{value:new i.Pq0(1,1,1)},uFade:{value:L.current?1:0}};O.current=C;const X=new i.D$Q({vertexShader:"\nprecision highp float;\nattribute vec3 position;\nvoid main(){\n  gl_Position = vec4(position, 1.0);\n}\n",fragmentShader:"\n#ifdef GL_ES\n#extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\nprecision mediump int;\n\nuniform float iTime;\nuniform vec3 iResolution;\nuniform vec4 iMouse;\nuniform float uWispDensity;\nuniform float uTiltScale;\nuniform float uFlowTime;\nuniform float uFogTime;\nuniform float uBeamXFrac;\nuniform float uBeamYFrac;\nuniform float uFlowSpeed;\nuniform float uVLenFactor;\nuniform float uHLenFactor;\nuniform float uFogIntensity;\nuniform float uFogScale;\nuniform float uWSpeed;\nuniform float uWIntensity;\nuniform float uFlowStrength;\nuniform float uDecay;\nuniform float uFalloffStart;\nuniform float uFogFallSpeed;\nuniform vec3 uColor;\nuniform float uFade;\n\n// Core beam/flare shaping and dynamics\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPS 1e-6\n#define EDGE_SOFT (DT_LOCAL*4.0)\n#define DT_LOCAL 0.0038\n#define TAP_RADIUS 6\n#define R_H 150.0\n#define R_V 150.0\n#define FLARE_HEIGHT 16.0\n#define FLARE_AMOUNT 8.0\n#define FLARE_EXP 2.0\n#define TOP_FADE_START 0.1\n#define TOP_FADE_EXP 1.0\n#define FLOW_PERIOD 0.5\n#define FLOW_SHARPNESS 1.5\n\n// Wisps (animated micro-streaks) that travel along the beam\n#define W_BASE_X 1.5\n#define W_LAYER_GAP 0.25\n#define W_LANES 10\n#define W_SIDE_DECAY 0.5\n#define W_HALF 0.01\n#define W_AA 0.15\n#define W_CELL 20.0\n#define W_SEG_MIN 0.01\n#define W_SEG_MAX 0.55\n#define W_CURVE_AMOUNT 15.0\n#define W_CURVE_RANGE (FLARE_HEIGHT - 3.0)\n#define W_BOTTOM_EXP 10.0\n\n// Volumetric fog controls\n#define FOG_ON 1\n#define FOG_CONTRAST 1.2\n#define FOG_SPEED_U 0.1\n#define FOG_SPEED_V -0.1\n#define FOG_OCTAVES 5\n#define FOG_BOTTOM_BIAS 0.8\n#define FOG_TILT_TO_MOUSE 0.05\n#define FOG_TILT_DEADZONE 0.01\n#define FOG_TILT_MAX_X 0.35\n#define FOG_TILT_SHAPE 1.5\n#define FOG_BEAM_MIN 0.0\n#define FOG_BEAM_MAX 0.75\n#define FOG_MASK_GAMMA 0.5\n#define FOG_EXPAND_SHAPE 12.2\n#define FOG_EDGE_MIX 0.5\n\n// Horizontal vignette for the fog volume\n#define HFOG_EDGE_START 0.20\n#define HFOG_EDGE_END 0.98\n#define HFOG_EDGE_GAMMA 1.4\n#define HFOG_Y_RADIUS 25.0\n#define HFOG_Y_SOFT 60.0\n\n// Beam extents and edge masking\n#define EDGE_X0 0.22\n#define EDGE_X1 0.995\n#define EDGE_X_GAMMA 1.25\n#define EDGE_LUMA_T0 0.0\n#define EDGE_LUMA_T1 2.0\n#define DITHER_STRENGTH 1.0\n\n    float g(float x){return x<=0.00031308?12.92*x:1.055*pow(x,1.0/2.4)-0.055;}\n    float bs(vec2 p,vec2 q,float powr){\n        float d=distance(p,q),f=powr*uFalloffStart,r=(f*f)/(d*d+EPS);\n        return powr*min(1.0,r);\n    }\n    float bsa(vec2 p,vec2 q,float powr,vec2 s){\n        vec2 d=p-q; float dd=(d.x*d.x)/(s.x*s.x)+(d.y*d.y)/(s.y*s.y),f=powr*uFalloffStart,r=(f*f)/(dd+EPS);\n        return powr*min(1.0,r);\n    }\n    float tri01(float x){float f=fract(x);return 1.0-abs(f*2.0-1.0);}\n    float tauWf(float t,float tmin,float tmax){float a=smoothstep(tmin,tmin+EDGE_SOFT,t),b=1.0-smoothstep(tmax-EDGE_SOFT,tmax,t);return max(0.0,a*b);} \n    float h21(vec2 p){p=fract(p*vec2(123.34,456.21));p+=dot(p,p+34.123);return fract(p.x*p.y);}\n    float vnoise(vec2 p){\n        vec2 i=floor(p),f=fract(p);\n        float a=h21(i),b=h21(i+vec2(1,0)),c=h21(i+vec2(0,1)),d=h21(i+vec2(1,1));\n        vec2 u=f*f*(3.0-2.0*f);\n        return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);\n    }\n    float fbm2(vec2 p){\n        float v=0.0,amp=0.6; mat2 m=mat2(0.86,0.5,-0.5,0.86);\n        for(int i=0;i<FOG_OCTAVES;++i){v+=amp*vnoise(p); p=m*p*2.03+17.1; amp*=0.52;}\n        return v;\n    }\n    float rGate(float x,float l){float a=smoothstep(0.0,W_AA,x),b=1.0-smoothstep(l,l+W_AA,x);return max(0.0,a*b);}\n    float flareY(float y){float t=clamp(1.0-(clamp(y,0.0,FLARE_HEIGHT)/max(FLARE_HEIGHT,EPS)),0.0,1.0);return pow(t,FLARE_EXP);}\n\n    float vWisps(vec2 uv,float topF){\n    float y=uv.y,yf=(y+uFlowTime*uWSpeed)/W_CELL;\n    float dRaw=clamp(uWispDensity,0.0,2.0),d=dRaw<=0.0?1.0:dRaw;\n    float lanesF=floor(float(W_LANES)*min(d,1.0)+0.5); // WebGL1-safe\n    int lanes=int(max(1.0,lanesF));\n    float sp=min(d,1.0),ep=max(d-1.0,0.0);\n    float fm=flareY(max(y,0.0)),rm=clamp(1.0-(y/max(W_CURVE_RANGE,EPS)),0.0,1.0),cm=fm*rm;\n    const float G=0.05; float xS=1.0+(FLARE_AMOUNT*W_CURVE_AMOUNT*G)*cm;\n    float sPix=clamp(y/R_V,0.0,1.0),bGain=pow(1.0-sPix,W_BOTTOM_EXP),sum=0.0;\n    for(int s=0;s<2;++s){\n        float sgn=s==0?-1.0:1.0;\n        for(int i=0;i<W_LANES;++i){\n            if(i>=lanes) break;\n            float off=W_BASE_X+float(i)*W_LAYER_GAP,xc=sgn*(off*xS);\n            float dx=abs(uv.x-xc),lat=1.0-smoothstep(W_HALF,W_HALF+W_AA,dx),amp=exp(-off*W_SIDE_DECAY);\n            float seed=h21(vec2(off,sgn*17.0)),yf2=yf+seed*7.0,ci=floor(yf2),fy=fract(yf2);\n            float seg=mix(W_SEG_MIN,W_SEG_MAX,h21(vec2(ci,off*2.3)));\n            float spR=h21(vec2(ci,off+sgn*31.0)),seg1=rGate(fy,seg)*step(spR,sp);\n            if(ep>0.0){float spR2=h21(vec2(ci*3.1+7.0,off*5.3+sgn*13.0)); float f2=fract(fy+0.5); seg1+=rGate(f2,seg*0.9)*step(spR2,ep);}\n            sum+=amp*lat*seg1;\n        }\n    }\n    float span=smoothstep(-3.0,0.0,y)*(1.0-smoothstep(R_V-6.0,R_V,y));\n    return uWIntensity*sum*topF*bGain*span;\n}\n\nvoid mainImage(out vec4 fc,in vec2 frag){\n    vec2 C=iResolution.xy*.5; float invW=1.0/max(C.x,1.0);\n    float sc=512.0/iResolution.x*.4;\n    vec2 uv=(frag-C)*sc,off=vec2(uBeamXFrac*iResolution.x*sc,uBeamYFrac*iResolution.y*sc);\n    vec2 uvc = uv - off;\n    float a=0.0,b=0.0;\n    float basePhase=1.5*PI+uDecay*.5; float tauMin=basePhase-uDecay; float tauMax=basePhase;\n    float cx=clamp(uvc.x/(R_H*uHLenFactor),-1.0,1.0),tH=clamp(TWO_PI-acos(cx),tauMin,tauMax);\n    for(int k=-TAP_RADIUS;k<=TAP_RADIUS;++k){\n        float tu=tH+float(k)*DT_LOCAL,wt=tauWf(tu,tauMin,tauMax); if(wt<=0.0) continue;\n        float spd=max(abs(sin(tu)),0.02),u=clamp((basePhase-tu)/max(uDecay,EPS),0.0,1.0),env=pow(1.0-abs(u*2.0-1.0),0.8);\n        vec2 p=vec2((R_H*uHLenFactor)*cos(tu),0.0);\n        a+=wt*bs(uvc,p,env*spd);\n    }\n    float yPix=uvc.y,cy=clamp(-yPix/(R_V*uVLenFactor),-1.0,1.0),tV=clamp(TWO_PI-acos(cy),tauMin,tauMax);\n    for(int k=-TAP_RADIUS;k<=TAP_RADIUS;++k){\n        float tu=tV+float(k)*DT_LOCAL,wt=tauWf(tu,tauMin,tauMax); if(wt<=0.0) continue;\n        float yb=(-R_V)*cos(tu),s=clamp(yb/R_V,0.0,1.0),spd=max(abs(sin(tu)),0.02);\n        float env=pow(1.0-s,0.6)*spd;\n        float cap=1.0-smoothstep(TOP_FADE_START,1.0,s); cap=pow(cap,TOP_FADE_EXP); env*=cap;\n        float ph=s/max(FLOW_PERIOD,EPS)+uFlowTime*uFlowSpeed;\n        float fl=pow(tri01(ph),FLOW_SHARPNESS);\n        env*=mix(1.0-uFlowStrength,1.0,fl);\n        float yp=(-R_V*uVLenFactor)*cos(tu),m=pow(smoothstep(FLARE_HEIGHT,0.0,yp),FLARE_EXP),wx=1.0+FLARE_AMOUNT*m;\n        vec2 sig=vec2(wx,1.0),p=vec2(0.0,yp);\n        float mask=step(0.0,yp);\n        b+=wt*bsa(uvc,p,mask*env,sig);\n    }\n    float sPix=clamp(yPix/R_V,0.0,1.0),topA=pow(1.0-smoothstep(TOP_FADE_START,1.0,sPix),TOP_FADE_EXP);\n    float L=a+b*topA;\n    float w=vWisps(vec2(uvc.x,yPix),topA);\n    float fog=0.0;\n#if FOG_ON\n    vec2 fuv=uvc*uFogScale;\n    float mAct=step(1.0,length(iMouse.xy)),nx=((iMouse.x-C.x)*invW)*mAct;\n    float ax = abs(nx);\n    float stMag = mix(ax, pow(ax, FOG_TILT_SHAPE), 0.35);\n    float st = sign(nx) * stMag * uTiltScale;\n    st = clamp(st, -FOG_TILT_MAX_X, FOG_TILT_MAX_X);\n    vec2 dir=normalize(vec2(st,1.0));\n    fuv+=uFogTime*uFogFallSpeed*dir;\n    vec2 prp=vec2(-dir.y,dir.x);\n    fuv+=prp*(0.08*sin(dot(uvc,prp)*0.08+uFogTime*0.9));\n    float n=fbm2(fuv+vec2(fbm2(fuv+vec2(7.3,2.1)),fbm2(fuv+vec2(-3.7,5.9)))*0.6);\n    n=pow(clamp(n,0.0,1.0),FOG_CONTRAST);\n    float pixW = 1.0 / max(iResolution.y, 1.0);\n#ifdef GL_OES_standard_derivatives\n    float wL = max(fwidth(L), pixW);\n#else\n    float wL = pixW;\n#endif\n    float m0=pow(smoothstep(FOG_BEAM_MIN - wL, FOG_BEAM_MAX + wL, L),FOG_MASK_GAMMA);\n    float bm=1.0-pow(1.0-m0,FOG_EXPAND_SHAPE); bm=mix(bm*m0,bm,FOG_EDGE_MIX);\n    float yP=1.0-smoothstep(HFOG_Y_RADIUS,HFOG_Y_RADIUS+HFOG_Y_SOFT,abs(yPix));\n    float nxF=abs((frag.x-C.x)*invW),hE=1.0-smoothstep(HFOG_EDGE_START,HFOG_EDGE_END,nxF); hE=pow(clamp(hE,0.0,1.0),HFOG_EDGE_GAMMA);\n    float hW=mix(1.0,hE,clamp(yP,0.0,1.0));\n    float bBias=mix(1.0,1.0-sPix,FOG_BOTTOM_BIAS);\n    float browserFogIntensity = uFogIntensity;\n    browserFogIntensity *= 1.8;\n    float radialFade = 1.0 - smoothstep(0.0, 0.7, length(uvc) / 120.0);\n    float safariFog = n * browserFogIntensity * bBias * bm * hW * radialFade;\n    fog = safariFog;\n#endif\n    float LF=L+fog;\n    float dith=(h21(frag)-0.5)*(DITHER_STRENGTH/255.0);\n    float tone=g(LF+w);\n    vec3 col=tone*uColor+dith;\n    float alpha=clamp(g(L+w*0.6)+dith*0.6,0.0,1.0);\n    float nxE=abs((frag.x-C.x)*invW),xF=pow(clamp(1.0-smoothstep(EDGE_X0,EDGE_X1,nxE),0.0,1.0),EDGE_X_GAMMA);\n    float scene=LF+max(0.0,w)*0.5,hi=smoothstep(EDGE_LUMA_T0,EDGE_LUMA_T1,scene);\n    float eM=mix(xF,1.0,hi);\n    col*=eM; alpha*=eM;\n    col*=uFade; alpha*=uFade;\n    fc=vec4(col,alpha);\n}\n\nvoid main(){\n  vec4 fc;\n  mainImage(fc, gl_FragCoord.xy);\n  gl_FragColor = fc;\n}\n",uniforms:C,transparent:!1,depthTest:!1,depthWrite:!1,blending:i.NTi}),N=new i.eaF(H,X);N.frustumCulled=!1,l.add(N);const B=new i.zD7;let U=0,V=L.current?1:0;const Y=new i.I9Y(0,0),k=new i.I9Y(0,0),q=()=>{const t=e.clientWidth||1,o=e.clientHeight||1,i=M.current;n.setPixelRatio(i),n.setSize(t,o,!1),C.iResolution.value.set(t*i,o*i,i),R.current=a.getBoundingClientRect()};let z=0;const j=()=>{z&&cancelAnimationFrame(z),z=requestAnimationFrame(q)};q();const $=new ResizeObserver(j);$.observe(e);const K=new IntersectionObserver(e=>{var n,t;const a=null===(n=null===(t=e[0])||void 0===t?void 0:t.isIntersecting)||void 0===n||n,o=I.current;I.current=a,!a||o||W.current||ae||(ae=requestAnimationFrame(le))},{root:null,threshold:0});K.observe(e);const Q=()=>{const e=W.current;W.current=document.hidden,!document.hidden&&e&&I.current&&!ae&&(ae=requestAnimationFrame(le))};document.addEventListener("visibilitychange",Q,{passive:!0});const Z=(0,r.n)((e,n)=>{R.current||(R.current=a.getBoundingClientRect());const t=R.current,o=e-t.left,i=n-t.top,r=M.current,l=t.height*r;Y.set(o*r,l-i*r)},16),J=e=>Z(e.clientX,e.clientY),ee=()=>{Y.set(0,0),R.current=null};a.addEventListener("pointermove",J,{passive:!0}),a.addEventListener("pointerdown",J,{passive:!0}),a.addEventListener("pointerenter",J,{passive:!0}),a.addEventListener("pointerleave",ee,{passive:!0});const ne=e=>{e.preventDefault(),W.current=!0,ae&&(cancelAnimationFrame(ae),ae=0)},te=()=>{W.current=!1,B.start(),U=0,L.current=!1,j();const e=O.current;e&&(e.iTime.value=0,e.uFlowTime.value=0,e.uFogTime.value=0,e.uFade.value=0),W.current||!I.current||ae||(ae=requestAnimationFrame(le))};a.addEventListener("webglcontextlost",ne,!1),a.addEventListener("webglcontextrestored",te,!1);let ae=0;const oe=(e,n,t)=>Math.max(n,Math.min(t,e));let ie=!1,re=null;const le=()=>{if(W.current||!I.current)return void(ae=0);const e=B.getElapsedTime(),t=Math.max(0,e-U);U=e;const a=1e3*t;b.current=.9*b.current+.1*a;const o=1e3/Math.max(1,b.current);D.current.push(o),C.iTime.value=e;const i=Math.min(.033,Math.max(.001,t));if(C.uFlowTime.value+=i,C.uFogTime.value+=i,!L.current){const e=1;V=Math.min(1,V+i/e),C.uFade.value=V,V>=1&&(L.current=!0)}const r=Math.max(.001,u),f=1-Math.exp(-i/r);k.lerp(Y,f),C.iMouse.value.set(k.x,k.y,0,0),n.render(l,g),(e=>{if(e-P.current<750)return;const n=D.current;if(0===n.length)return void(P.current=e);const t=n.reduce((e,n)=>e+n,0)/n.length;let a=M.current;const o=y.current;t<50?a=oe(.9*M.current,.6,o):t>58&&M.current<o&&(a=oe(1.05*M.current,.6,o)),Math.abs(a-M.current)>.01&&(re=a,ie||(ie=!0,requestAnimationFrame(()=>{null!==re&&(M.current=re,q(),re=null),ie=!1}))),D.current=[],P.current=e})(performance.now()),ae=!W.current&&I.current?requestAnimationFrame(le):0};return!W.current&&I.current&&(ae=requestAnimationFrame(le)),()=>{cancelAnimationFrame(ae),$.disconnect(),K.disconnect(),document.removeEventListener("visibilitychange",Q),a.removeEventListener("pointermove",J),a.removeEventListener("pointerdown",J),a.removeEventListener("pointerenter",J),a.removeEventListener("pointerleave",ee),a.removeEventListener("webglcontextlost",ne),a.removeEventListener("webglcontextrestored",te),H.dispose(),X.dispose(),n.dispose(),e.contains(a)&&e.removeChild(a)}},[f]),(0,a.useEffect)(()=>{const e=O.current;if(!e)return;e.uWispDensity.value=t,e.uTiltScale.value=s,e.uBeamXFrac.value=c,e.uBeamYFrac.value=m,e.uFlowSpeed.value=d,e.uVLenFactor.value=p,e.uHLenFactor.value=_,e.uFogIntensity.value=v,e.uFogScale.value=F,e.uWSpeed.value=E,e.uWIntensity.value=A,e.uFlowStrength.value=x,e.uDecay.value=h,e.uFalloffStart.value=S,e.uFogFallSpeed.value=T;const{r:n,g:a,b:o}=(e=>{let n=e.trim();"#"===n[0]&&(n=n.slice(1)),3===n.length&&(n=n.split("").map(e=>e+e).join(""));const t=parseInt(n,16)||16777215;return{r:(t>>16&255)/255,g:(t>>8&255)/255,b:(255&t)/255}})(g||"#FFFFFF");e.uColor.value.set(n,a,o)},[t,s,c,m,d,p,_,v,F,E,A,x,h,S,T,g]),(0,l.jsx)("div",{ref:w,className:`w-full h-full relative ${e||""}`,style:n})},u=f}}]);
//# sourceMappingURL=382.12552a3e.chunk.js.map